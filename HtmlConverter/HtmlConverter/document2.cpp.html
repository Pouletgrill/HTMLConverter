<html><head>
<head>
<title>document2.cpp</title>
<meta charset = 'UTF-8'>
<link rel = 'stylesheet' type = 'text/css' href = 'Style.css'>
</head>
<body>
<pre>
/*<br>Xavier Brosseau<br>Charlie Laplante<br>*/<br>#<span style='color:blue'>include</span> &lt;iostream&gt;<br>#<span style='color:blue'>include</span> &lt;map&gt;<br>#<span style='color:blue'>include</span> &lt;fstream&gt;<br>#<span style='color:blue'>include</span> &lt;string&gt;<br>#<span style='color:blue'>include</span> &lt;vector&gt;<br>#<span style='color:blue'>include</span> &lt;iterator&gt;<br>#<span style='color:blue'>include</span> &lt;algorithm&gt;<br>#<span style='color:blue'>include</span> &lt;regex&gt;<br>#<span style='color:blue'>include</span> &lt;thread&gt;<br>#<span style='color:blue'>include</span> &lt;chrono&gt;<br><span style='color:blue'>using</span> <span style='color:blue'>namespace</span> std;<br><span style='color:blue'>using</span> <span style='color:blue'>namespace</span> chrono;<br><br><br><br><span style='color:blue'>bool</span> FileExist(string &amp;filename)<br>{<br>	<span style='color:blue'>return</span> ifstream{ filename }.good();<br>}<br><br><span style='color:blue'>template</span>&lt;<span style='color:blue'>class</span> it, <span style='color:blue'>class</span> T&gt;<br><span style='color:blue'>bool</span> AnalyseParameter(it debut, it fin, <span style='color:blue'>const</span> T &amp;pred)<br>{<br>	<span style='color:blue'>return</span> find_if(debut, fin, pred) != fin;<br>}<br><br><span style='color:blue'>template</span>&lt;<span style='color:blue'>class</span> it, <span style='color:blue'>class</span> T&gt;<br><span style='color:blue'>bool</span> FindFichier(it param, <span style='color:blue'>const</span> T &amp;pred)<br>{<br>	<span style='color:blue'>return</span> pred(*param) &amp;&amp; FileExist(*param);<br>}<br><br><span style='color:blue'>void</span> convertirHtml(<span style='color:blue'>bool</span> couleur, <span style='color:blue'>bool</span> stat, map&lt;string, <span style='color:blue'>int</span>&gt; htmlMap, string filename)<br>{<br>	ifstream file(filename);<br>	vector&lt;string&gt; FileTemp;<br>	<span style='color:blue'>for</span> (string s; getline(file, s);)<br>		FileTemp.push_back(s);<br><br><br>	ofstream myHtmlFile;<br>	myHtmlFile.open(filename + ".html");//Création du fichier<br>										//Header<br>	myHtmlFile &lt;&lt; "&lt;html&gt;&lt;head&gt;" &lt;&lt; "\n" &lt;&lt;<br>		"&lt;head&gt;" &lt;&lt; "\n" &lt;&lt;<br>		"&lt;title&gt;" &lt;&lt; filename &lt;&lt; "&lt;/title&gt;\n" &lt;&lt;<br>		"&lt;meta charset = 'UTF-8'&gt;\n" &lt;&lt;<br>		"&lt;link rel = 'stylesheet' type = 'text/css' href = 'Style.css'&gt;\n" &lt;&lt;<br>		"&lt;/head&gt;\n" &lt;&lt;<br>		"&lt;body&gt;\n" &lt;&lt;<br>		"&lt;pre&gt;\n";<br><br><br><br>	//Creation du fichier Stats<br>	<span style='color:blue'>if</span> (stat)<br>	{<br>		file.open(filename);<br>		ofstream myfile;<br>		myfile.open(filename + "Stats.txt");<br>		//build map<br>		<span style='color:blue'>for</span> (string s; file &gt;&gt; s;)<br>			htmlMap[s]++;<br><br>		regex ExpressKeyWord{ "\\w+" };<br>		regex ExpressNumeric{ "\\d+\\.*\\d*\\w*" };<br><br>		<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp;p : htmlMap)<br>		{<br>			<span style='color:blue'>if</span> (regex_match(p.first, ExpressKeyWord) || regex_match(p.first, ExpressNumeric))<br>			{<br>				myfile &lt;&lt; p.first &lt;&lt; " / " &lt;&lt; p.second &lt;&lt; "\n";<br>			}<br>		}<br>		myfile.close();<br>		file.close();<br>	}<br><br><br>	//Contenue<br>	<span style='color:blue'>if</span> (couleur)<br>	{<br>		file.open(filename);<br><br><br>		vector&lt;string&gt;listCPP = {<br>			"<span style='color:blue'>alignas</span>","<span style='color:blue'>alignof</span>","<span style='color:blue'>and</span>","<span style='color:blue'>and_eq</span>","<span style='color:blue'>asm</span>"<br>			,"<span style='color:blue'>auto</span>","<span style='color:blue'>bitand</span>","<span style='color:blue'>bitor</span>","<span style='color:blue'>bool</span>"<br>			,"<span style='color:blue'>break</span>","<span style='color:blue'>case</span>","<span style='color:blue'>catch</span>","<span style='color:blue'>char</span>"<br>			,"<span style='color:blue'>class</span>","<span style='color:blue'>compl</span>","<span style='color:blue'>const</span>","<span style='color:blue'>constexpr</span>"<br>			,"<span style='color:blue'>const_cast</span>","<span style='color:blue'>continue</span>","<span style='color:blue'>decltype</span>","<span style='color:blue'>default</span>"<br>			,"<span style='color:blue'>delete</span>","<span style='color:blue'>do</span>","<span style='color:blue'>double</span>","<span style='color:blue'>dynamic_cast</span>"<br>			,"<span style='color:blue'>else</span>","<span style='color:blue'>enum</span>","<span style='color:blue'>explicit</span>","<span style='color:blue'>export</span>"<br>			,"<span style='color:blue'>extern</span>","<span style='color:blue'>false</span>","<span style='color:blue'>float</span>","<span style='color:blue'>for</span>"<br>			,"<span style='color:blue'>friend</span>","<span style='color:blue'>goto</span>","<span style='color:blue'>if</span>","<span style='color:blue'>inline</span>"<br>			,"<span style='color:blue'>int</span>","<span style='color:blue'>include</span>","<span style='color:blue'>long</span>","<span style='color:blue'>mutable</span>"<br>			,"<span style='color:blue'>namespace</span>","<span style='color:blue'>new</span>","<span style='color:blue'>noexcept</span>","<span style='color:blue'>not</span>"<br>			,"<span style='color:blue'>not_eq</span>","<span style='color:blue'>nullptr</span>","<span style='color:blue'>operator</span>","<span style='color:blue'>or</span>"<br>			,"<span style='color:blue'>or_eq</span>","<span style='color:blue'>private</span>","<span style='color:blue'>protected</span>","<span style='color:blue'>public</span>"<br>			,"<span style='color:blue'>register</span>","<span style='color:blue'>reinterpret_cast</span>","<span style='color:blue'>return</span>","<span style='color:blue'>short</span>"<br>			,"<span style='color:blue'>signed</span>","<span style='color:blue'>sizeof</span>","<span style='color:blue'>static</span>","<span style='color:blue'>static_assert</span>"<br>			,"<span style='color:blue'>static_cast</span>","<span style='color:blue'>struct</span>","<span style='color:blue'>switch</span>","<span style='color:blue'>template</span>"<br>			,"<span style='color:blue'>this</span>","<span style='color:blue'>thread_local</span>","<span style='color:blue'>throw</span>","<span style='color:blue'>true</span>"<br>			,"<span style='color:blue'>try</span>","<span style='color:blue'>typedef</span>","<span style='color:blue'>typeid</span>","<span style='color:blue'>typename</span>"<br>			,"<span style='color:blue'>union</span>","<span style='color:blue'>unsigned</span>","<span style='color:blue'>using</span>","<span style='color:blue'>virtual</span>"<br>			,"<span style='color:blue'>void</span>","<span style='color:blue'>volatile</span>","<span style='color:blue'>wchar_t</span>","<span style='color:blue'>while</span>"<br>			,"<span style='color:blue'>xor</span>","<span style='color:blue'>xor_eq</span>" };<br><br><br>		regex Express;<br>		<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; begin : FileTemp)<br>		{<br>			begin = regex_replace(begin, regex{ "&amp;" }, "&amp;amp;");<br>			begin = regex_replace(begin, regex{ "&lt;" }, "&amp;lt;");<br>			begin = regex_replace(begin, regex{ "&gt;" }, "&amp;gt;");<br><br>			<span style='color:blue'>for</span> (vector&lt;string&gt;::iterator keywordPos = listCPP.begin(); keywordPos != listCPP.end(); ++keywordPos)<br>			{<br>				Express = "\\b" + *keywordPos + "\\b";<br><br>				begin = regex_replace(begin, Express, "&lt;span style='color:blue'&gt;" + *keywordPos + "&lt;/span&gt;");<br>			}<br>			myHtmlFile &lt;&lt; begin &lt;&lt; "&lt;br&gt;" &lt;&lt; flush;<br>		}<br>		file.close();<br>	}<br>	<span style='color:blue'>else</span><br>	{<br>		file.open(filename);<br><br>		<span style='color:blue'>for</span> (vector&lt;string&gt;::iterator begin = FileTemp.begin(); begin != FileTemp.end(); ++begin)<br>		{<br>			*begin = regex_replace(*begin, regex{ "&amp;" }, "&amp;amp;");<br>			*begin = regex_replace(*begin, regex{ "&lt;" }, "&amp;lt;");<br>			*begin = regex_replace(*begin, regex{ "&gt;" }, "&amp;gt;");<br>			myHtmlFile &lt;&lt; *begin &lt;&lt; "&lt;br&gt;" &lt;&lt; flush;<br>		}<br>		file.close();<br>	}<br>	//footer<br>	myHtmlFile &lt;&lt; "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n";<br>	myHtmlFile.close();<br>}<br><br><br><br><br><span style='color:blue'>int</span> main(<span style='color:blue'>int</span> argc, <span style='color:blue'>char</span>* argv[])<br>{<br>	<span style='color:blue'>const</span> <span style='color:blue'>int</span> nbCoeur = thread::hardware_concurrency();<br>	ofstream statfile("statfichier.txt", ios::app);<br>	<span style='color:blue'>const</span> <span style='color:blue'>int</span> NbFichier = 30;<br>	<span style='color:blue'>for</span> (<span style='color:blue'>int</span> k = 1; k &lt;= NbFichier; ++k)<br>	{<br><br>		vector&lt;string&gt; arguments(argv + 1, argv + argc);<br>		//Forcer des arguments ICI<br>		//-------------------------<br>		arguments.push_back("-stat");<br>		arguments.push_back("-couleur");<br>		<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; k; i++)<br>		{<br>			arguments.push_back("document1.cpp");<br>		}<br><br>		<span style='color:blue'>if</span> (!arguments.empty())<br>		{<br>			//Check les paramètres<br>			<span style='color:blue'>bool</span> couleur = AnalyseParameter(begin(arguments),<br>				end(arguments),<br>				[](string param) {<span style='color:blue'>return</span> param == "/couleur" || param == "-couleur"; });<br>			<span style='color:blue'>bool</span> stat = AnalyseParameter(begin(arguments),<br>				end(arguments),<br>				[](string param) {<span style='color:blue'>return</span> param == "/stat" || param == "-stat"; });<br><br>			//la map html<br>			map&lt;string, <span style='color:blue'>int</span>&gt; htmlMap;<br>			vector&lt;string&gt;::iterator it = begin(arguments);<br>			<br>			//Sequenciel<br>			//ce promène dans la liste d'argument pour trouver les fichiers qui existe et qui respectent le predicat<br>			<br>			/**/high_resolution_clock::time_point tempSequenceDebut = high_resolution_clock::now();<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1);<br>				<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str) c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					convertirHtml(couleur, stat, htmlMap, filename);<br>				}<br>			}<br>			high_resolution_clock::time_point tempSequenceFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_Seq = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempSequenceFin - tempSequenceDebut);/**/<br><br>			//Thread Pool<br>			vector&lt;thread&gt; lesThreads;<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; nbCoeur; ++i)<br>			{<br>				lesThreads.push_back(thread());<br>			}<br>			it = begin(arguments);<br><br>			high_resolution_clock::time_point tempTPDebut = high_resolution_clock::now();<br>			<span style='color:blue'>int</span> i = 0;<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1); <span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str)<br>					c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					<span style='color:blue'>int</span> tempo = i%nbCoeur;<br>					<span style='color:blue'>if</span> (lesThreads[tempo].joinable())<br>						lesThreads[tempo].join();<br>					lesThreads[tempo] = thread(convertirHtml, couleur, stat, htmlMap, filename);<br>				}<br>				++i;<br>			}<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; nbCoeur; ++i)<br>			{<br>				<span style='color:blue'>if</span> (lesThreads[i].joinable())<br>					lesThreads[i].join();<br>			}<br>			high_resolution_clock::time_point tempTPFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_TP = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempTPFin - tempTPDebut);<br><br>			//Parallele<br>			vector&lt;thread&gt; lesThreads2;<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; arguments.size(); ++i)<br>			{<br>				lesThreads2.push_back(thread());<br>			}<br>			it = begin(arguments);<br><br>			high_resolution_clock::time_point tempParaDebut = high_resolution_clock::now();<br>			<span style='color:blue'>int</span> i2 = 0;<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1); <span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str)<br>					c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					lesThreads2[i2] = thread(convertirHtml, couleur, stat, htmlMap, filename);<br>				}<br>				++i2;<br>			}<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i2 = 0; i2 &lt; arguments.size(); ++i2)<br>			{<br>				<span style='color:blue'>if</span> (lesThreads2[i2].joinable())<br>					lesThreads2[i2].join();<br>			}<br>			high_resolution_clock::time_point tempParaFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_Para = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempParaFin - tempParaDebut);<br><br>			<br>			statfile &lt;&lt; time_span_Seq.count() &lt;&lt; "\t" &lt;&lt; time_span_TP.count() &lt;&lt; "\t" &lt;&lt; time_span_Para.count() &lt;&lt; "\n";<br><br>		}<br>		<span style='color:blue'>else</span><br>		{<br>			cout &lt;&lt; "vous avez entre aucun parametre" &lt;&lt; endl;<br>		}<br>	}<br>}<br>/*<br>Xavier Brosseau<br>Charlie Laplante<br>*/<br>#<span style='color:blue'>include</span> &lt;iostream&gt;<br>#<span style='color:blue'>include</span> &lt;map&gt;<br>#<span style='color:blue'>include</span> &lt;fstream&gt;<br>#<span style='color:blue'>include</span> &lt;string&gt;<br>#<span style='color:blue'>include</span> &lt;vector&gt;<br>#<span style='color:blue'>include</span> &lt;iterator&gt;<br>#<span style='color:blue'>include</span> &lt;algorithm&gt;<br>#<span style='color:blue'>include</span> &lt;regex&gt;<br>#<span style='color:blue'>include</span> &lt;thread&gt;<br>#<span style='color:blue'>include</span> &lt;chrono&gt;<br><span style='color:blue'>using</span> <span style='color:blue'>namespace</span> std;<br><span style='color:blue'>using</span> <span style='color:blue'>namespace</span> chrono;<br><br><br><br><span style='color:blue'>bool</span> FileExist(string &amp;filename)<br>{<br>	<span style='color:blue'>return</span> ifstream{ filename }.good();<br>}<br><br><span style='color:blue'>template</span>&lt;<span style='color:blue'>class</span> it, <span style='color:blue'>class</span> T&gt;<br><span style='color:blue'>bool</span> AnalyseParameter(it debut, it fin, <span style='color:blue'>const</span> T &amp;pred)<br>{<br>	<span style='color:blue'>return</span> find_if(debut, fin, pred) != fin;<br>}<br><br><span style='color:blue'>template</span>&lt;<span style='color:blue'>class</span> it, <span style='color:blue'>class</span> T&gt;<br><span style='color:blue'>bool</span> FindFichier(it param, <span style='color:blue'>const</span> T &amp;pred)<br>{<br>	<span style='color:blue'>return</span> pred(*param) &amp;&amp; FileExist(*param);<br>}<br><br><span style='color:blue'>void</span> convertirHtml(<span style='color:blue'>bool</span> couleur, <span style='color:blue'>bool</span> stat, map&lt;string, <span style='color:blue'>int</span>&gt; htmlMap, string filename)<br>{<br>	ifstream file(filename);<br>	vector&lt;string&gt; FileTemp;<br>	<span style='color:blue'>for</span> (string s; getline(file, s);)<br>		FileTemp.push_back(s);<br><br><br>	ofstream myHtmlFile;<br>	myHtmlFile.open(filename + ".html");//Création du fichier<br>										//Header<br>	myHtmlFile &lt;&lt; "&lt;html&gt;&lt;head&gt;" &lt;&lt; "\n" &lt;&lt;<br>		"&lt;head&gt;" &lt;&lt; "\n" &lt;&lt;<br>		"&lt;title&gt;" &lt;&lt; filename &lt;&lt; "&lt;/title&gt;\n" &lt;&lt;<br>		"&lt;meta charset = 'UTF-8'&gt;\n" &lt;&lt;<br>		"&lt;link rel = 'stylesheet' type = 'text/css' href = 'Style.css'&gt;\n" &lt;&lt;<br>		"&lt;/head&gt;\n" &lt;&lt;<br>		"&lt;body&gt;\n" &lt;&lt;<br>		"&lt;pre&gt;\n";<br><br><br><br>	//Creation du fichier Stats<br>	<span style='color:blue'>if</span> (stat)<br>	{<br>		file.open(filename);<br>		ofstream myfile;<br>		myfile.open(filename + "Stats.txt");<br>		//build map<br>		<span style='color:blue'>for</span> (string s; file &gt;&gt; s;)<br>			htmlMap[s]++;<br><br>		regex ExpressKeyWord{ "\\w+" };<br>		regex ExpressNumeric{ "\\d+\\.*\\d*\\w*" };<br><br>		<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp;p : htmlMap)<br>		{<br>			<span style='color:blue'>if</span> (regex_match(p.first, ExpressKeyWord) || regex_match(p.first, ExpressNumeric))<br>			{<br>				myfile &lt;&lt; p.first &lt;&lt; " / " &lt;&lt; p.second &lt;&lt; "\n";<br>			}<br>		}<br>		myfile.close();<br>		file.close();<br>	}<br><br><br>	//Contenue<br>	<span style='color:blue'>if</span> (couleur)<br>	{<br>		file.open(filename);<br><br><br>		vector&lt;string&gt;listCPP = {<br>			"<span style='color:blue'>alignas</span>","<span style='color:blue'>alignof</span>","<span style='color:blue'>and</span>","<span style='color:blue'>and_eq</span>","<span style='color:blue'>asm</span>"<br>			,"<span style='color:blue'>auto</span>","<span style='color:blue'>bitand</span>","<span style='color:blue'>bitor</span>","<span style='color:blue'>bool</span>"<br>			,"<span style='color:blue'>break</span>","<span style='color:blue'>case</span>","<span style='color:blue'>catch</span>","<span style='color:blue'>char</span>"<br>			,"<span style='color:blue'>class</span>","<span style='color:blue'>compl</span>","<span style='color:blue'>const</span>","<span style='color:blue'>constexpr</span>"<br>			,"<span style='color:blue'>const_cast</span>","<span style='color:blue'>continue</span>","<span style='color:blue'>decltype</span>","<span style='color:blue'>default</span>"<br>			,"<span style='color:blue'>delete</span>","<span style='color:blue'>do</span>","<span style='color:blue'>double</span>","<span style='color:blue'>dynamic_cast</span>"<br>			,"<span style='color:blue'>else</span>","<span style='color:blue'>enum</span>","<span style='color:blue'>explicit</span>","<span style='color:blue'>export</span>"<br>			,"<span style='color:blue'>extern</span>","<span style='color:blue'>false</span>","<span style='color:blue'>float</span>","<span style='color:blue'>for</span>"<br>			,"<span style='color:blue'>friend</span>","<span style='color:blue'>goto</span>","<span style='color:blue'>if</span>","<span style='color:blue'>inline</span>"<br>			,"<span style='color:blue'>int</span>","<span style='color:blue'>include</span>","<span style='color:blue'>long</span>","<span style='color:blue'>mutable</span>"<br>			,"<span style='color:blue'>namespace</span>","<span style='color:blue'>new</span>","<span style='color:blue'>noexcept</span>","<span style='color:blue'>not</span>"<br>			,"<span style='color:blue'>not_eq</span>","<span style='color:blue'>nullptr</span>","<span style='color:blue'>operator</span>","<span style='color:blue'>or</span>"<br>			,"<span style='color:blue'>or_eq</span>","<span style='color:blue'>private</span>","<span style='color:blue'>protected</span>","<span style='color:blue'>public</span>"<br>			,"<span style='color:blue'>register</span>","<span style='color:blue'>reinterpret_cast</span>","<span style='color:blue'>return</span>","<span style='color:blue'>short</span>"<br>			,"<span style='color:blue'>signed</span>","<span style='color:blue'>sizeof</span>","<span style='color:blue'>static</span>","<span style='color:blue'>static_assert</span>"<br>			,"<span style='color:blue'>static_cast</span>","<span style='color:blue'>struct</span>","<span style='color:blue'>switch</span>","<span style='color:blue'>template</span>"<br>			,"<span style='color:blue'>this</span>","<span style='color:blue'>thread_local</span>","<span style='color:blue'>throw</span>","<span style='color:blue'>true</span>"<br>			,"<span style='color:blue'>try</span>","<span style='color:blue'>typedef</span>","<span style='color:blue'>typeid</span>","<span style='color:blue'>typename</span>"<br>			,"<span style='color:blue'>union</span>","<span style='color:blue'>unsigned</span>","<span style='color:blue'>using</span>","<span style='color:blue'>virtual</span>"<br>			,"<span style='color:blue'>void</span>","<span style='color:blue'>volatile</span>","<span style='color:blue'>wchar_t</span>","<span style='color:blue'>while</span>"<br>			,"<span style='color:blue'>xor</span>","<span style='color:blue'>xor_eq</span>" };<br><br><br>		regex Express;<br>		<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; begin : FileTemp)<br>		{<br>			begin = regex_replace(begin, regex{ "&amp;" }, "&amp;amp;");<br>			begin = regex_replace(begin, regex{ "&lt;" }, "&amp;lt;");<br>			begin = regex_replace(begin, regex{ "&gt;" }, "&amp;gt;");<br><br>			<span style='color:blue'>for</span> (vector&lt;string&gt;::iterator keywordPos = listCPP.begin(); keywordPos != listCPP.end(); ++keywordPos)<br>			{<br>				Express = "\\b" + *keywordPos + "\\b";<br><br>				begin = regex_replace(begin, Express, "&lt;span style='color:blue'&gt;" + *keywordPos + "&lt;/span&gt;");<br>			}<br>			myHtmlFile &lt;&lt; begin &lt;&lt; "&lt;br&gt;" &lt;&lt; flush;<br>		}<br>		file.close();<br>	}<br>	<span style='color:blue'>else</span><br>	{<br>		file.open(filename);<br><br>		<span style='color:blue'>for</span> (vector&lt;string&gt;::iterator begin = FileTemp.begin(); begin != FileTemp.end(); ++begin)<br>		{<br>			*begin = regex_replace(*begin, regex{ "&amp;" }, "&amp;amp;");<br>			*begin = regex_replace(*begin, regex{ "&lt;" }, "&amp;lt;");<br>			*begin = regex_replace(*begin, regex{ "&gt;" }, "&amp;gt;");<br>			myHtmlFile &lt;&lt; *begin &lt;&lt; "&lt;br&gt;" &lt;&lt; flush;<br>		}<br>		file.close();<br>	}<br>	//footer<br>	myHtmlFile &lt;&lt; "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n";<br>	myHtmlFile.close();<br>}<br><br><br><br><br><span style='color:blue'>int</span> main(<span style='color:blue'>int</span> argc, <span style='color:blue'>char</span>* argv[])<br>{<br>	<span style='color:blue'>const</span> <span style='color:blue'>int</span> nbCoeur = thread::hardware_concurrency();<br>	ofstream statfile("statfichier.txt", ios::app);<br>	<span style='color:blue'>const</span> <span style='color:blue'>int</span> NbFichier = 30;<br>	<span style='color:blue'>for</span> (<span style='color:blue'>int</span> k = 1; k &lt;= NbFichier; ++k)<br>	{<br><br>		vector&lt;string&gt; arguments(argv + 1, argv + argc);<br>		//Forcer des arguments ICI<br>		//-------------------------<br>		arguments.push_back("-stat");<br>		arguments.push_back("-couleur");<br>		<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; k; i++)<br>		{<br>			arguments.push_back("document1.cpp");<br>		}<br><br>		<span style='color:blue'>if</span> (!arguments.empty())<br>		{<br>			//Check les paramètres<br>			<span style='color:blue'>bool</span> couleur = AnalyseParameter(begin(arguments),<br>				end(arguments),<br>				[](string param) {<span style='color:blue'>return</span> param == "/couleur" || param == "-couleur"; });<br>			<span style='color:blue'>bool</span> stat = AnalyseParameter(begin(arguments),<br>				end(arguments),<br>				[](string param) {<span style='color:blue'>return</span> param == "/stat" || param == "-stat"; });<br><br>			//la map html<br>			map&lt;string, <span style='color:blue'>int</span>&gt; htmlMap;<br>			vector&lt;string&gt;::iterator it = begin(arguments);<br>			<br>			//Sequenciel<br>			//ce promène dans la liste d'argument pour trouver les fichiers qui existe et qui respectent le predicat<br>			<br>			/**/high_resolution_clock::time_point tempSequenceDebut = high_resolution_clock::now();<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1);<br>				<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str) c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					convertirHtml(couleur, stat, htmlMap, filename);<br>				}<br>			}<br>			high_resolution_clock::time_point tempSequenceFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_Seq = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempSequenceFin - tempSequenceDebut);/**/<br><br>			//Thread Pool<br>			vector&lt;thread&gt; lesThreads;<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; nbCoeur; ++i)<br>			{<br>				lesThreads.push_back(thread());<br>			}<br>			it = begin(arguments);<br><br>			high_resolution_clock::time_point tempTPDebut = high_resolution_clock::now();<br>			<span style='color:blue'>int</span> i = 0;<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1); <span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str)<br>					c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					<span style='color:blue'>int</span> tempo = i%nbCoeur;<br>					<span style='color:blue'>if</span> (lesThreads[tempo].joinable())<br>						lesThreads[tempo].join();<br>					lesThreads[tempo] = thread(convertirHtml, couleur, stat, htmlMap, filename);<br>				}<br>				++i;<br>			}<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; nbCoeur; ++i)<br>			{<br>				<span style='color:blue'>if</span> (lesThreads[i].joinable())<br>					lesThreads[i].join();<br>			}<br>			high_resolution_clock::time_point tempTPFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_TP = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempTPFin - tempTPDebut);<br><br>			//Parallele<br>			vector&lt;thread&gt; lesThreads2;<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; arguments.size(); ++i)<br>			{<br>				lesThreads2.push_back(thread());<br>			}<br>			it = begin(arguments);<br><br>			high_resolution_clock::time_point tempParaDebut = high_resolution_clock::now();<br>			<span style='color:blue'>int</span> i2 = 0;<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1); <span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str)<br>					c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					lesThreads2[i2] = thread(convertirHtml, couleur, stat, htmlMap, filename);<br>				}<br>				++i2;<br>			}<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i2 = 0; i2 &lt; arguments.size(); ++i2)<br>			{<br>				<span style='color:blue'>if</span> (lesThreads2[i2].joinable())<br>					lesThreads2[i2].join();<br>			}<br>			high_resolution_clock::time_point tempParaFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_Para = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempParaFin - tempParaDebut);<br><br>			<br>			statfile &lt;&lt; time_span_Seq.count() &lt;&lt; "\t" &lt;&lt; time_span_TP.count() &lt;&lt; "\t" &lt;&lt; time_span_Para.count() &lt;&lt; "\n";<br><br>		}<br>		<span style='color:blue'>else</span><br>		{<br>			cout &lt;&lt; "vous avez entre aucun parametre" &lt;&lt; endl;<br>		}<br>	}<br>}<br>/*<br>Xavier Brosseau<br>Charlie Laplante<br>*/<br>#<span style='color:blue'>include</span> &lt;iostream&gt;<br>#<span style='color:blue'>include</span> &lt;map&gt;<br>#<span style='color:blue'>include</span> &lt;fstream&gt;<br>#<span style='color:blue'>include</span> &lt;string&gt;<br>#<span style='color:blue'>include</span> &lt;vector&gt;<br>#<span style='color:blue'>include</span> &lt;iterator&gt;<br>#<span style='color:blue'>include</span> &lt;algorithm&gt;<br>#<span style='color:blue'>include</span> &lt;regex&gt;<br>#<span style='color:blue'>include</span> &lt;thread&gt;<br>#<span style='color:blue'>include</span> &lt;chrono&gt;<br><span style='color:blue'>using</span> <span style='color:blue'>namespace</span> std;<br><span style='color:blue'>using</span> <span style='color:blue'>namespace</span> chrono;<br><br><br><br><span style='color:blue'>bool</span> FileExist(string &amp;filename)<br>{<br>	<span style='color:blue'>return</span> ifstream{ filename }.good();<br>}<br><br><span style='color:blue'>template</span>&lt;<span style='color:blue'>class</span> it, <span style='color:blue'>class</span> T&gt;<br><span style='color:blue'>bool</span> AnalyseParameter(it debut, it fin, <span style='color:blue'>const</span> T &amp;pred)<br>{<br>	<span style='color:blue'>return</span> find_if(debut, fin, pred) != fin;<br>}<br><br><span style='color:blue'>template</span>&lt;<span style='color:blue'>class</span> it, <span style='color:blue'>class</span> T&gt;<br><span style='color:blue'>bool</span> FindFichier(it param, <span style='color:blue'>const</span> T &amp;pred)<br>{<br>	<span style='color:blue'>return</span> pred(*param) &amp;&amp; FileExist(*param);<br>}<br><br><span style='color:blue'>void</span> convertirHtml(<span style='color:blue'>bool</span> couleur, <span style='color:blue'>bool</span> stat, map&lt;string, <span style='color:blue'>int</span>&gt; htmlMap, string filename)<br>{<br>	ifstream file(filename);<br>	vector&lt;string&gt; FileTemp;<br>	<span style='color:blue'>for</span> (string s; getline(file, s);)<br>		FileTemp.push_back(s);<br><br><br>	ofstream myHtmlFile;<br>	myHtmlFile.open(filename + ".html");//Création du fichier<br>										//Header<br>	myHtmlFile &lt;&lt; "&lt;html&gt;&lt;head&gt;" &lt;&lt; "\n" &lt;&lt;<br>		"&lt;head&gt;" &lt;&lt; "\n" &lt;&lt;<br>		"&lt;title&gt;" &lt;&lt; filename &lt;&lt; "&lt;/title&gt;\n" &lt;&lt;<br>		"&lt;meta charset = 'UTF-8'&gt;\n" &lt;&lt;<br>		"&lt;link rel = 'stylesheet' type = 'text/css' href = 'Style.css'&gt;\n" &lt;&lt;<br>		"&lt;/head&gt;\n" &lt;&lt;<br>		"&lt;body&gt;\n" &lt;&lt;<br>		"&lt;pre&gt;\n";<br><br><br><br>	//Creation du fichier Stats<br>	<span style='color:blue'>if</span> (stat)<br>	{<br>		file.open(filename);<br>		ofstream myfile;<br>		myfile.open(filename + "Stats.txt");<br>		//build map<br>		<span style='color:blue'>for</span> (string s; file &gt;&gt; s;)<br>			htmlMap[s]++;<br><br>		regex ExpressKeyWord{ "\\w+" };<br>		regex ExpressNumeric{ "\\d+\\.*\\d*\\w*" };<br><br>		<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp;p : htmlMap)<br>		{<br>			<span style='color:blue'>if</span> (regex_match(p.first, ExpressKeyWord) || regex_match(p.first, ExpressNumeric))<br>			{<br>				myfile &lt;&lt; p.first &lt;&lt; " / " &lt;&lt; p.second &lt;&lt; "\n";<br>			}<br>		}<br>		myfile.close();<br>		file.close();<br>	}<br><br><br>	//Contenue<br>	<span style='color:blue'>if</span> (couleur)<br>	{<br>		file.open(filename);<br><br><br>		vector&lt;string&gt;listCPP = {<br>			"<span style='color:blue'>alignas</span>","<span style='color:blue'>alignof</span>","<span style='color:blue'>and</span>","<span style='color:blue'>and_eq</span>","<span style='color:blue'>asm</span>"<br>			,"<span style='color:blue'>auto</span>","<span style='color:blue'>bitand</span>","<span style='color:blue'>bitor</span>","<span style='color:blue'>bool</span>"<br>			,"<span style='color:blue'>break</span>","<span style='color:blue'>case</span>","<span style='color:blue'>catch</span>","<span style='color:blue'>char</span>"<br>			,"<span style='color:blue'>class</span>","<span style='color:blue'>compl</span>","<span style='color:blue'>const</span>","<span style='color:blue'>constexpr</span>"<br>			,"<span style='color:blue'>const_cast</span>","<span style='color:blue'>continue</span>","<span style='color:blue'>decltype</span>","<span style='color:blue'>default</span>"<br>			,"<span style='color:blue'>delete</span>","<span style='color:blue'>do</span>","<span style='color:blue'>double</span>","<span style='color:blue'>dynamic_cast</span>"<br>			,"<span style='color:blue'>else</span>","<span style='color:blue'>enum</span>","<span style='color:blue'>explicit</span>","<span style='color:blue'>export</span>"<br>			,"<span style='color:blue'>extern</span>","<span style='color:blue'>false</span>","<span style='color:blue'>float</span>","<span style='color:blue'>for</span>"<br>			,"<span style='color:blue'>friend</span>","<span style='color:blue'>goto</span>","<span style='color:blue'>if</span>","<span style='color:blue'>inline</span>"<br>			,"<span style='color:blue'>int</span>","<span style='color:blue'>include</span>","<span style='color:blue'>long</span>","<span style='color:blue'>mutable</span>"<br>			,"<span style='color:blue'>namespace</span>","<span style='color:blue'>new</span>","<span style='color:blue'>noexcept</span>","<span style='color:blue'>not</span>"<br>			,"<span style='color:blue'>not_eq</span>","<span style='color:blue'>nullptr</span>","<span style='color:blue'>operator</span>","<span style='color:blue'>or</span>"<br>			,"<span style='color:blue'>or_eq</span>","<span style='color:blue'>private</span>","<span style='color:blue'>protected</span>","<span style='color:blue'>public</span>"<br>			,"<span style='color:blue'>register</span>","<span style='color:blue'>reinterpret_cast</span>","<span style='color:blue'>return</span>","<span style='color:blue'>short</span>"<br>			,"<span style='color:blue'>signed</span>","<span style='color:blue'>sizeof</span>","<span style='color:blue'>static</span>","<span style='color:blue'>static_assert</span>"<br>			,"<span style='color:blue'>static_cast</span>","<span style='color:blue'>struct</span>","<span style='color:blue'>switch</span>","<span style='color:blue'>template</span>"<br>			,"<span style='color:blue'>this</span>","<span style='color:blue'>thread_local</span>","<span style='color:blue'>throw</span>","<span style='color:blue'>true</span>"<br>			,"<span style='color:blue'>try</span>","<span style='color:blue'>typedef</span>","<span style='color:blue'>typeid</span>","<span style='color:blue'>typename</span>"<br>			,"<span style='color:blue'>union</span>","<span style='color:blue'>unsigned</span>","<span style='color:blue'>using</span>","<span style='color:blue'>virtual</span>"<br>			,"<span style='color:blue'>void</span>","<span style='color:blue'>volatile</span>","<span style='color:blue'>wchar_t</span>","<span style='color:blue'>while</span>"<br>			,"<span style='color:blue'>xor</span>","<span style='color:blue'>xor_eq</span>" };<br><br><br>		regex Express;<br>		<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; begin : FileTemp)<br>		{<br>			begin = regex_replace(begin, regex{ "&amp;" }, "&amp;amp;");<br>			begin = regex_replace(begin, regex{ "&lt;" }, "&amp;lt;");<br>			begin = regex_replace(begin, regex{ "&gt;" }, "&amp;gt;");<br><br>			<span style='color:blue'>for</span> (vector&lt;string&gt;::iterator keywordPos = listCPP.begin(); keywordPos != listCPP.end(); ++keywordPos)<br>			{<br>				Express = "\\b" + *keywordPos + "\\b";<br><br>				begin = regex_replace(begin, Express, "&lt;span style='color:blue'&gt;" + *keywordPos + "&lt;/span&gt;");<br>			}<br>			myHtmlFile &lt;&lt; begin &lt;&lt; "&lt;br&gt;" &lt;&lt; flush;<br>		}<br>		file.close();<br>	}<br>	<span style='color:blue'>else</span><br>	{<br>		file.open(filename);<br><br>		<span style='color:blue'>for</span> (vector&lt;string&gt;::iterator begin = FileTemp.begin(); begin != FileTemp.end(); ++begin)<br>		{<br>			*begin = regex_replace(*begin, regex{ "&amp;" }, "&amp;amp;");<br>			*begin = regex_replace(*begin, regex{ "&lt;" }, "&amp;lt;");<br>			*begin = regex_replace(*begin, regex{ "&gt;" }, "&amp;gt;");<br>			myHtmlFile &lt;&lt; *begin &lt;&lt; "&lt;br&gt;" &lt;&lt; flush;<br>		}<br>		file.close();<br>	}<br>	//footer<br>	myHtmlFile &lt;&lt; "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n";<br>	myHtmlFile.close();<br>}<br><br><br><br><br><span style='color:blue'>int</span> main(<span style='color:blue'>int</span> argc, <span style='color:blue'>char</span>* argv[])<br>{<br>	<span style='color:blue'>const</span> <span style='color:blue'>int</span> nbCoeur = thread::hardware_concurrency();<br>	ofstream statfile("statfichier.txt", ios::app);<br>	<span style='color:blue'>const</span> <span style='color:blue'>int</span> NbFichier = 30;<br>	<span style='color:blue'>for</span> (<span style='color:blue'>int</span> k = 1; k &lt;= NbFichier; ++k)<br>	{<br><br>		vector&lt;string&gt; arguments(argv + 1, argv + argc);<br>		//Forcer des arguments ICI<br>		//-------------------------<br>		arguments.push_back("-stat");<br>		arguments.push_back("-couleur");<br>		<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; k; i++)<br>		{<br>			arguments.push_back("document1.cpp");<br>		}<br><br>		<span style='color:blue'>if</span> (!arguments.empty())<br>		{<br>			//Check les paramètres<br>			<span style='color:blue'>bool</span> couleur = AnalyseParameter(begin(arguments),<br>				end(arguments),<br>				[](string param) {<span style='color:blue'>return</span> param == "/couleur" || param == "-couleur"; });<br>			<span style='color:blue'>bool</span> stat = AnalyseParameter(begin(arguments),<br>				end(arguments),<br>				[](string param) {<span style='color:blue'>return</span> param == "/stat" || param == "-stat"; });<br><br>			//la map html<br>			map&lt;string, <span style='color:blue'>int</span>&gt; htmlMap;<br>			vector&lt;string&gt;::iterator it = begin(arguments);<br>			<br>			//Sequenciel<br>			//ce promène dans la liste d'argument pour trouver les fichiers qui existe et qui respectent le predicat<br>			<br>			/**/high_resolution_clock::time_point tempSequenceDebut = high_resolution_clock::now();<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1);<br>				<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str) c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					convertirHtml(couleur, stat, htmlMap, filename);<br>				}<br>			}<br>			high_resolution_clock::time_point tempSequenceFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_Seq = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempSequenceFin - tempSequenceDebut);/**/<br><br>			//Thread Pool<br>			vector&lt;thread&gt; lesThreads;<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; nbCoeur; ++i)<br>			{<br>				lesThreads.push_back(thread());<br>			}<br>			it = begin(arguments);<br><br>			high_resolution_clock::time_point tempTPDebut = high_resolution_clock::now();<br>			<span style='color:blue'>int</span> i = 0;<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1); <span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str)<br>					c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					<span style='color:blue'>int</span> tempo = i%nbCoeur;<br>					<span style='color:blue'>if</span> (lesThreads[tempo].joinable())<br>						lesThreads[tempo].join();<br>					lesThreads[tempo] = thread(convertirHtml, couleur, stat, htmlMap, filename);<br>				}<br>				++i;<br>			}<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; nbCoeur; ++i)<br>			{<br>				<span style='color:blue'>if</span> (lesThreads[i].joinable())<br>					lesThreads[i].join();<br>			}<br>			high_resolution_clock::time_point tempTPFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_TP = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempTPFin - tempTPDebut);<br><br>			//Parallele<br>			vector&lt;thread&gt; lesThreads2;<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; arguments.size(); ++i)<br>			{<br>				lesThreads2.push_back(thread());<br>			}<br>			it = begin(arguments);<br><br>			high_resolution_clock::time_point tempParaDebut = high_resolution_clock::now();<br>			<span style='color:blue'>int</span> i2 = 0;<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1); <span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str)<br>					c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					lesThreads2[i2] = thread(convertirHtml, couleur, stat, htmlMap, filename);<br>				}<br>				++i2;<br>			}<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i2 = 0; i2 &lt; arguments.size(); ++i2)<br>			{<br>				<span style='color:blue'>if</span> (lesThreads2[i2].joinable())<br>					lesThreads2[i2].join();<br>			}<br>			high_resolution_clock::time_point tempParaFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_Para = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempParaFin - tempParaDebut);<br><br>			<br>			statfile &lt;&lt; time_span_Seq.count() &lt;&lt; "\t" &lt;&lt; time_span_TP.count() &lt;&lt; "\t" &lt;&lt; time_span_Para.count() &lt;&lt; "\n";<br><br>		}<br>		<span style='color:blue'>else</span><br>		{<br>			cout &lt;&lt; "vous avez entre aucun parametre" &lt;&lt; endl;<br>		}<br>	}<br>}<br>/*<br>Xavier Brosseau<br>Charlie Laplante<br>*/<br>#<span style='color:blue'>include</span> &lt;iostream&gt;<br>#<span style='color:blue'>include</span> &lt;map&gt;<br>#<span style='color:blue'>include</span> &lt;fstream&gt;<br>#<span style='color:blue'>include</span> &lt;string&gt;<br>#<span style='color:blue'>include</span> &lt;vector&gt;<br>#<span style='color:blue'>include</span> &lt;iterator&gt;<br>#<span style='color:blue'>include</span> &lt;algorithm&gt;<br>#<span style='color:blue'>include</span> &lt;regex&gt;<br>#<span style='color:blue'>include</span> &lt;thread&gt;<br>#<span style='color:blue'>include</span> &lt;chrono&gt;<br><span style='color:blue'>using</span> <span style='color:blue'>namespace</span> std;<br><span style='color:blue'>using</span> <span style='color:blue'>namespace</span> chrono;<br><br><br><br><span style='color:blue'>bool</span> FileExist(string &amp;filename)<br>{<br>	<span style='color:blue'>return</span> ifstream{ filename }.good();<br>}<br><br><span style='color:blue'>template</span>&lt;<span style='color:blue'>class</span> it, <span style='color:blue'>class</span> T&gt;<br><span style='color:blue'>bool</span> AnalyseParameter(it debut, it fin, <span style='color:blue'>const</span> T &amp;pred)<br>{<br>	<span style='color:blue'>return</span> find_if(debut, fin, pred) != fin;<br>}<br><br><span style='color:blue'>template</span>&lt;<span style='color:blue'>class</span> it, <span style='color:blue'>class</span> T&gt;<br><span style='color:blue'>bool</span> FindFichier(it param, <span style='color:blue'>const</span> T &amp;pred)<br>{<br>	<span style='color:blue'>return</span> pred(*param) &amp;&amp; FileExist(*param);<br>}<br><br><span style='color:blue'>void</span> convertirHtml(<span style='color:blue'>bool</span> couleur, <span style='color:blue'>bool</span> stat, map&lt;string, <span style='color:blue'>int</span>&gt; htmlMap, string filename)<br>{<br>	ifstream file(filename);<br>	vector&lt;string&gt; FileTemp;<br>	<span style='color:blue'>for</span> (string s; getline(file, s);)<br>		FileTemp.push_back(s);<br><br><br>	ofstream myHtmlFile;<br>	myHtmlFile.open(filename + ".html");//Création du fichier<br>										//Header<br>	myHtmlFile &lt;&lt; "&lt;html&gt;&lt;head&gt;" &lt;&lt; "\n" &lt;&lt;<br>		"&lt;head&gt;" &lt;&lt; "\n" &lt;&lt;<br>		"&lt;title&gt;" &lt;&lt; filename &lt;&lt; "&lt;/title&gt;\n" &lt;&lt;<br>		"&lt;meta charset = 'UTF-8'&gt;\n" &lt;&lt;<br>		"&lt;link rel = 'stylesheet' type = 'text/css' href = 'Style.css'&gt;\n" &lt;&lt;<br>		"&lt;/head&gt;\n" &lt;&lt;<br>		"&lt;body&gt;\n" &lt;&lt;<br>		"&lt;pre&gt;\n";<br><br><br><br>	//Creation du fichier Stats<br>	<span style='color:blue'>if</span> (stat)<br>	{<br>		file.open(filename);<br>		ofstream myfile;<br>		myfile.open(filename + "Stats.txt");<br>		//build map<br>		<span style='color:blue'>for</span> (string s; file &gt;&gt; s;)<br>			htmlMap[s]++;<br><br>		regex ExpressKeyWord{ "\\w+" };<br>		regex ExpressNumeric{ "\\d+\\.*\\d*\\w*" };<br><br>		<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp;p : htmlMap)<br>		{<br>			<span style='color:blue'>if</span> (regex_match(p.first, ExpressKeyWord) || regex_match(p.first, ExpressNumeric))<br>			{<br>				myfile &lt;&lt; p.first &lt;&lt; " / " &lt;&lt; p.second &lt;&lt; "\n";<br>			}<br>		}<br>		myfile.close();<br>		file.close();<br>	}<br><br><br>	//Contenue<br>	<span style='color:blue'>if</span> (couleur)<br>	{<br>		file.open(filename);<br><br><br>		vector&lt;string&gt;listCPP = {<br>			"<span style='color:blue'>alignas</span>","<span style='color:blue'>alignof</span>","<span style='color:blue'>and</span>","<span style='color:blue'>and_eq</span>","<span style='color:blue'>asm</span>"<br>			,"<span style='color:blue'>auto</span>","<span style='color:blue'>bitand</span>","<span style='color:blue'>bitor</span>","<span style='color:blue'>bool</span>"<br>			,"<span style='color:blue'>break</span>","<span style='color:blue'>case</span>","<span style='color:blue'>catch</span>","<span style='color:blue'>char</span>"<br>			,"<span style='color:blue'>class</span>","<span style='color:blue'>compl</span>","<span style='color:blue'>const</span>","<span style='color:blue'>constexpr</span>"<br>			,"<span style='color:blue'>const_cast</span>","<span style='color:blue'>continue</span>","<span style='color:blue'>decltype</span>","<span style='color:blue'>default</span>"<br>			,"<span style='color:blue'>delete</span>","<span style='color:blue'>do</span>","<span style='color:blue'>double</span>","<span style='color:blue'>dynamic_cast</span>"<br>			,"<span style='color:blue'>else</span>","<span style='color:blue'>enum</span>","<span style='color:blue'>explicit</span>","<span style='color:blue'>export</span>"<br>			,"<span style='color:blue'>extern</span>","<span style='color:blue'>false</span>","<span style='color:blue'>float</span>","<span style='color:blue'>for</span>"<br>			,"<span style='color:blue'>friend</span>","<span style='color:blue'>goto</span>","<span style='color:blue'>if</span>","<span style='color:blue'>inline</span>"<br>			,"<span style='color:blue'>int</span>","<span style='color:blue'>include</span>","<span style='color:blue'>long</span>","<span style='color:blue'>mutable</span>"<br>			,"<span style='color:blue'>namespace</span>","<span style='color:blue'>new</span>","<span style='color:blue'>noexcept</span>","<span style='color:blue'>not</span>"<br>			,"<span style='color:blue'>not_eq</span>","<span style='color:blue'>nullptr</span>","<span style='color:blue'>operator</span>","<span style='color:blue'>or</span>"<br>			,"<span style='color:blue'>or_eq</span>","<span style='color:blue'>private</span>","<span style='color:blue'>protected</span>","<span style='color:blue'>public</span>"<br>			,"<span style='color:blue'>register</span>","<span style='color:blue'>reinterpret_cast</span>","<span style='color:blue'>return</span>","<span style='color:blue'>short</span>"<br>			,"<span style='color:blue'>signed</span>","<span style='color:blue'>sizeof</span>","<span style='color:blue'>static</span>","<span style='color:blue'>static_assert</span>"<br>			,"<span style='color:blue'>static_cast</span>","<span style='color:blue'>struct</span>","<span style='color:blue'>switch</span>","<span style='color:blue'>template</span>"<br>			,"<span style='color:blue'>this</span>","<span style='color:blue'>thread_local</span>","<span style='color:blue'>throw</span>","<span style='color:blue'>true</span>"<br>			,"<span style='color:blue'>try</span>","<span style='color:blue'>typedef</span>","<span style='color:blue'>typeid</span>","<span style='color:blue'>typename</span>"<br>			,"<span style='color:blue'>union</span>","<span style='color:blue'>unsigned</span>","<span style='color:blue'>using</span>","<span style='color:blue'>virtual</span>"<br>			,"<span style='color:blue'>void</span>","<span style='color:blue'>volatile</span>","<span style='color:blue'>wchar_t</span>","<span style='color:blue'>while</span>"<br>			,"<span style='color:blue'>xor</span>","<span style='color:blue'>xor_eq</span>" };<br><br><br>		regex Express;<br>		<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; begin : FileTemp)<br>		{<br>			begin = regex_replace(begin, regex{ "&amp;" }, "&amp;amp;");<br>			begin = regex_replace(begin, regex{ "&lt;" }, "&amp;lt;");<br>			begin = regex_replace(begin, regex{ "&gt;" }, "&amp;gt;");<br><br>			<span style='color:blue'>for</span> (vector&lt;string&gt;::iterator keywordPos = listCPP.begin(); keywordPos != listCPP.end(); ++keywordPos)<br>			{<br>				Express = "\\b" + *keywordPos + "\\b";<br><br>				begin = regex_replace(begin, Express, "&lt;span style='color:blue'&gt;" + *keywordPos + "&lt;/span&gt;");<br>			}<br>			myHtmlFile &lt;&lt; begin &lt;&lt; "&lt;br&gt;" &lt;&lt; flush;<br>		}<br>		file.close();<br>	}<br>	<span style='color:blue'>else</span><br>	{<br>		file.open(filename);<br><br>		<span style='color:blue'>for</span> (vector&lt;string&gt;::iterator begin = FileTemp.begin(); begin != FileTemp.end(); ++begin)<br>		{<br>			*begin = regex_replace(*begin, regex{ "&amp;" }, "&amp;amp;");<br>			*begin = regex_replace(*begin, regex{ "&lt;" }, "&amp;lt;");<br>			*begin = regex_replace(*begin, regex{ "&gt;" }, "&amp;gt;");<br>			myHtmlFile &lt;&lt; *begin &lt;&lt; "&lt;br&gt;" &lt;&lt; flush;<br>		}<br>		file.close();<br>	}<br>	//footer<br>	myHtmlFile &lt;&lt; "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n";<br>	myHtmlFile.close();<br>}<br><br><br><br><br><span style='color:blue'>int</span> main(<span style='color:blue'>int</span> argc, <span style='color:blue'>char</span>* argv[])<br>{<br>	<span style='color:blue'>const</span> <span style='color:blue'>int</span> nbCoeur = thread::hardware_concurrency();<br>	ofstream statfile("statfichier.txt", ios::app);<br>	<span style='color:blue'>const</span> <span style='color:blue'>int</span> NbFichier = 30;<br>	<span style='color:blue'>for</span> (<span style='color:blue'>int</span> k = 1; k &lt;= NbFichier; ++k)<br>	{<br><br>		vector&lt;string&gt; arguments(argv + 1, argv + argc);<br>		//Forcer des arguments ICI<br>		//-------------------------<br>		arguments.push_back("-stat");<br>		arguments.push_back("-couleur");<br>		<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; k; i++)<br>		{<br>			arguments.push_back("document1.cpp");<br>		}<br><br>		<span style='color:blue'>if</span> (!arguments.empty())<br>		{<br>			//Check les paramètres<br>			<span style='color:blue'>bool</span> couleur = AnalyseParameter(begin(arguments),<br>				end(arguments),<br>				[](string param) {<span style='color:blue'>return</span> param == "/couleur" || param == "-couleur"; });<br>			<span style='color:blue'>bool</span> stat = AnalyseParameter(begin(arguments),<br>				end(arguments),<br>				[](string param) {<span style='color:blue'>return</span> param == "/stat" || param == "-stat"; });<br><br>			//la map html<br>			map&lt;string, <span style='color:blue'>int</span>&gt; htmlMap;<br>			vector&lt;string&gt;::iterator it = begin(arguments);<br>			<br>			//Sequenciel<br>			//ce promène dans la liste d'argument pour trouver les fichiers qui existe et qui respectent le predicat<br>			<br>			/**/high_resolution_clock::time_point tempSequenceDebut = high_resolution_clock::now();<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1);<br>				<span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str) c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					convertirHtml(couleur, stat, htmlMap, filename);<br>				}<br>			}<br>			high_resolution_clock::time_point tempSequenceFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_Seq = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempSequenceFin - tempSequenceDebut);/**/<br><br>			//Thread Pool<br>			vector&lt;thread&gt; lesThreads;<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; nbCoeur; ++i)<br>			{<br>				lesThreads.push_back(thread());<br>			}<br>			it = begin(arguments);<br><br>			high_resolution_clock::time_point tempTPDebut = high_resolution_clock::now();<br>			<span style='color:blue'>int</span> i = 0;<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1); <span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str)<br>					c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					<span style='color:blue'>int</span> tempo = i%nbCoeur;<br>					<span style='color:blue'>if</span> (lesThreads[tempo].joinable())<br>						lesThreads[tempo].join();<br>					lesThreads[tempo] = thread(convertirHtml, couleur, stat, htmlMap, filename);<br>				}<br>				++i;<br>			}<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; nbCoeur; ++i)<br>			{<br>				<span style='color:blue'>if</span> (lesThreads[i].joinable())<br>					lesThreads[i].join();<br>			}<br>			high_resolution_clock::time_point tempTPFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_TP = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempTPFin - tempTPDebut);<br><br>			//Parallele<br>			vector&lt;thread&gt; lesThreads2;<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i = 0; i &lt; arguments.size(); ++i)<br>			{<br>				lesThreads2.push_back(thread());<br>			}<br>			it = begin(arguments);<br><br>			high_resolution_clock::time_point tempParaDebut = high_resolution_clock::now();<br>			<span style='color:blue'>int</span> i2 = 0;<br>			<span style='color:blue'>for</span> (string filename; it != end(arguments); it++)<br>			{<br>				<span style='color:blue'>if</span> (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1); <span style='color:blue'>for</span> (<span style='color:blue'>auto</span> &amp; c : str)<br>					c = toupper(c); <span style='color:blue'>return</span>  str == "CPP"; }))<br>				{<br>					filename = *it;<br>					lesThreads2[i2] = thread(convertirHtml, couleur, stat, htmlMap, filename);<br>				}<br>				++i2;<br>			}<br>			<span style='color:blue'>for</span> (<span style='color:blue'>int</span> i2 = 0; i2 &lt; arguments.size(); ++i2)<br>			{<br>				<span style='color:blue'>if</span> (lesThreads2[i2].joinable())<br>					lesThreads2[i2].join();<br>			}<br>			high_resolution_clock::time_point tempParaFin = high_resolution_clock::now();<br>			duration&lt;<span style='color:blue'>double</span>&gt; time_span_Para = duration_cast&lt;duration&lt;<span style='color:blue'>double</span>&gt;&gt;(tempParaFin - tempParaDebut);<br><br>			<br>			statfile &lt;&lt; time_span_Seq.count() &lt;&lt; "\t" &lt;&lt; time_span_TP.count() &lt;&lt; "\t" &lt;&lt; time_span_Para.count() &lt;&lt; "\n";<br><br>		}<br>		<span style='color:blue'>else</span><br>		{<br>			cout &lt;&lt; "vous avez entre aucun parametre" &lt;&lt; endl;<br>		}<br>	}<br>}<br></pre></body></html>

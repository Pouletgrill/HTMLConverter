<html><head>
<head>
<title>fuck.cpp</title>
<meta charset = 'UTF-8'>
<link rel = 'stylesheet' type = 'text/css' href = 'Style.css'>
</head>
<body>
<pre>
#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;fstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;iterator&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;regex&gt;<br>using namespace std;<br><br><br><br>bool FileExist(string filename)<br>{<br>	return ifstream{ filename }.good();<br>}<br><br>template&lt;class it, class T&gt;<br>bool AnalyseParameter(it debut, it end, const T &amp;pred)<br>{<br>	for (; debut != end; ++debut)<br>	{<br>		if (pred(*debut))<br>			return true;<br>	}<br>	return false;<br>}<br><br>template&lt;class it, class T&gt;<br>bool FindFichier(it param, const T &amp;pred)<br>{<br>	return pred(*param) &amp;&amp; FileExist(*param);<br>}<br><br>void convertirHtml(bool couleur, bool stat, map&lt;string, int&gt; htmlMap, string filename)<br>{<br>	ifstream file(filename);<br><br>	ofstream myHtmlFile;<br>	myHtmlFile.open(filename + ".html");//Création du fichier<br>										//Header<br>	myHtmlFile &lt;&lt; "&lt;html&gt;&lt;head&gt;" &lt;&lt; endl &lt;&lt;<br>		"&lt;head&gt;" &lt;&lt; endl &lt;&lt;<br>		"&lt;title&gt;" &lt;&lt; filename &lt;&lt; "&lt;/title&gt;" &lt;&lt; endl &lt;&lt;<br>		"&lt;meta charset = 'UTF-8'&gt;" &lt;&lt; endl &lt;&lt;<br>		"&lt;link rel = 'stylesheet' type = 'text/css' href = 'Style.css'&gt;" &lt;&lt; endl &lt;&lt;<br>		"&lt;/head&gt;" &lt;&lt; endl &lt;&lt;<br>		"&lt;body&gt;" &lt;&lt; endl &lt;&lt;<br>		"&lt;pre&gt;" &lt;&lt; endl;<br><br>	<br><br>	//Creation du fichier Stats<br>	if (stat)<br>	{<br>		ofstream myfile;<br>		myfile.open("Stats.txt");<br>		//build map<br>		for (string s; file &gt;&gt; s;)<br>			htmlMap[s]++;<br>		<br>		regex bitch{ "\\w+" };<br>		regex bitch2{ "\\d+\\.*\\d*\\w*" };<br>		<br>		for (auto &amp;p : htmlMap)<br>		{<br>			if(regex_match(p.first,bitch) || regex_match(p.first, bitch2))<br>			{<br>				myfile &lt;&lt; p.first &lt;&lt; " / " &lt;&lt; p.second &lt;&lt; endl;<br>			}			<br>		}			<br>		myfile.close();<br>	}<br>	<br>		<br>	//Contenue<br>	if (couleur)<br>	{<br>		myHtmlFile &lt;&lt; filename &lt;&lt; " + couleur" &lt;&lt; "&lt;br&gt;";<br>		ifstream in(filename);<br>		<br>		vector&lt;string&gt; FileTemp;<br>		for (string s; getline(in, s);)<br>			FileTemp.push_back(s);<br><br>		vector&lt;string&gt; listCPP = {<br>			"alignas"<br>			,"alignof"<br>			,"and"<br>			,"and_eq"<br>			,"asm"<br>			,"auto"<br>			,"bitand"<br>			,"bitor"<br>			,"bool"<br>			,"break"<br>			,"case"<br>			,"catch"<br>			,"char"<br>			,"class"<br>			,"compl"<br>			,"const"<br>			,"constexpr"<br>			,"const_cast"<br>			,"continue"<br>			,"decltype"<br>			,"default"<br>			,"delete"<br>			,"do"<br>			,"double"<br>			,"dynamic_cast"<br>			,"else"<br>			,"enum"<br>			,"explicit"<br>			,"export"<br>			,"extern"<br>			,"false"<br>			,"float"<br>			,"for"<br>			,"friend"<br>			,"goto"<br>			,"if"<br>			,"inline"<br>			,"int"<br>			,"long"<br>			,"mutable"<br>			,"namespace"<br>			,"new"<br>			,"noexcept"<br>			,"not"<br>			,"not_eq"<br>			,"nullptr"<br>			,"operator"<br>			,"or"<br>			,"or_eq"<br>			,"private"<br>			,"protected"<br>			,"public"<br>			,"register"<br>			,"reinterpret_cast"<br>			,"return"<br>			,"short"<br>			,"signed"<br>			,"sizeof"<br>			,"static"<br>			,"static_assert"<br>			,"static_cast"<br>			,"struct"<br>			,"switch"<br>			,"template"<br>			,"this"<br>			,"thread_local"<br>			,"throw"<br>			,"true"<br>			,"try"<br>			,"typedef"<br>			,"typeid"<br>			,"typename"<br>			,"union"<br>			,"unsigned"<br>			,"using"<br>			,"virtual"<br>			,"void"<br>			,"volatile"<br>			,"wchar_t"<br>			,"while"<br>			,"xor"<br>			,"xor_eq" };<br><br>		regex expression1;	<br><br><br>		for (vector&lt;string&gt;::iterator begin = FileTemp.begin(); begin != FileTemp.end(); ++begin)<br>		{<br>			*begin = regex_replace(*begin, regex{ "&amp;" }, "&amp;amp;");<br>			*begin = regex_replace(*begin, regex{ "&lt;" }, "&amp;lt;");<br>			*begin = regex_replace(*begin, regex{ "&gt;" }, "&amp;gt;");<br>			<br>			for (vector&lt;string&gt;::iterator keywordPos = listCPP.begin(); keywordPos != listCPP.end(); ++keywordPos)<br>			{<br>				 expression1 = "\\b" + *keywordPos + "\\b";<br>				<br>				*begin = regex_replace(*begin, expression1, "&lt;span style='color:blue'&gt;" + *keywordPos + "&lt;/span&gt;");				<br>			}<br>			myHtmlFile &lt;&lt; *begin &lt;&lt; "&lt;br&gt;" &lt;&lt; flush;<br>		}<br>	}<br>	else<br>	{<br>		ifstream in(filename);<br>		vector&lt;string&gt; FileTemp;<br>		for (string s; getline(in, s);)<br>			FileTemp.push_back(s);<br><br>		for (vector&lt;string&gt;::iterator begin = FileTemp.begin(); begin != FileTemp.end(); ++begin)<br>		{<br>			*begin = regex_replace(*begin, regex{ "&amp;" }, "&amp;amp;");<br>			*begin = regex_replace(*begin, regex{ "&lt;" }, "&amp;lt;");<br>			*begin = regex_replace(*begin, regex{ "&gt;" }, "&amp;gt;");<br>		   	myHtmlFile &lt;&lt; *begin &lt;&lt; "&lt;br&gt;" &lt;&lt; flush;<br>		}<br>	}	<br>	//footer<br>	myHtmlFile &lt;&lt; "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;" &lt;&lt; endl;<br>	myHtmlFile.close();<br>}<br><br><br><br><br>int main(int argc, char* argv[])<br>{<br>	vector&lt;string&gt; arguments(argv, argv + argc);<br>	arguments.push_back("-stat");	<br>	arguments.push_back("fuck.cpp");<br><br>	<br><br>	//Enlever premier argument qui est le nom de l'executable<br>	arguments.erase(arguments.begin());<br>	if (!arguments.empty())<br>	{<br>		//Check les paramètres<br>		bool couleur = AnalyseParameter(begin(arguments), end(arguments), [](string param) {return param == "/couleur" || param == "-couleur"; });<br>		bool stat = AnalyseParameter(begin(arguments), end(arguments), [](string param) {return param == "/stat" || param == "-stat"; });<br><br>		//la map html<br>		map&lt;string, int&gt; htmlMap;<br><br>		//ce promène dans la liste d'argument pour trouver les fichiers qui existe et qui respectent le predicat<br>		vector&lt;string&gt;::iterator it = begin(arguments);<br>		for (string filename; it != end(arguments); it++)<br>		{<br>			if (FindFichier(it, [](string param) {string str = param.substr(param.find_last_of(".") + 1);<br>			for (auto &amp; c : str) c = toupper(c); return  str == "CPP"; }))<br>			{<br>				filename = *it;				<br>				convertirHtml(couleur, stat, htmlMap, filename);				<br>			}<br>		}<br>	}<br>	else<br>	{<br>		cout &lt;&lt; "Pas de parametre" &lt;&lt; endl;<br>	}<br>	return 0;<br>}<br></pre></body></html>
